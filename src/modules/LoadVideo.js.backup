export default class LoadVideo {
    constructor(instance, app) {
        this.instance = instance
        this.app = app
        this.video = instance.querySelector("video") || instance
        this.source = this.video.querySelector("source")
        this.isLoaded = false
        this.observer = null
        
        // CRITICAL: Store reference on video element for WebGL coordination
        this.video._loadVideoInstance = this
        
        // Device detection
        this.isMobile = window.innerWidth <= 992
        this.isLowPowerMode = this.detectLowPowerMode()
        
        // Get video sources
        this.mobileUrl = this.source.dataset.srcMobile
        this.desktopUrl = this.source.dataset.src
        this.url = this.isMobile && this.mobileUrl ? this.mobileUrl : this.desktopUrl
        
        // Check if lazy loading is disabled OR if WebGL needs immediate loading
        const shouldLazyLoad = !instance.hasAttribute("data-hard-load") && !this.needsWebGLTexture()
        
        if (shouldLazyLoad) {
            this.setupLazyLoading()
        } else {
            this.loadVideo()
        }
    }

    needsWebGLTexture() {
        // Check if parent has WebGL-related classes
        const webglClasses = ['.double-video', '.cases_video', '.preview_img', '.talk_full']
        return webglClasses.some(className => 
            this.instance.closest(className.substring(1)) || 
            this.instance.classList.contains(className.substring(1))
        )
    }

    detectLowPowerMode() {
        // Check for reduced motion preference
        if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
            return true
        }
        
        // Check connection type if available
        if (navigator.connection) {
            const connection = navigator.connection
            return connection.saveData || connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g'
        }
        
        return false
    }

    setupLazyLoading() {
        if (!('IntersectionObserver' in window)) {
            // Fallback for old browsers
            this.loadVideo()
            return
        }

        const rootMargin = this.isMobile ? '50px' : '100px'
        
        this.observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !this.isLoaded) {
                    this.loadVideo()
                    this.observer.disconnect()
                }
            })
        }, {
            rootMargin,
            threshold: 0.1
        })

        this.observer.observe(this.video)
    }

    loadVideo() {
        if (this.isLoaded) return
        this.isLoaded = true

        // Set optimal preload strategy
        if (this.isMobile || this.isLowPowerMode) {
            this.video.preload = 'metadata'
            this.setupUserInteractionUpgrade()
        } else {
            this.video.preload = 'auto'
        }

        // Set video source
        this.source.setAttribute("src", this.url)
        
        // Load and setup event listeners
        this.video.load()
        this.setupVideoEvents()
    }

    setupUserInteractionUpgrade() {
        const upgradePreload = () => {
            this.video.preload = 'auto'
            this.video.load()
        }

        // Upgrade on first user interaction
        const events = ['touchstart', 'scroll', 'click']
        const cleanup = () => {
            events.forEach(event => {
                document.removeEventListener(event, upgradePreload, { passive: true })
            })
        }

        events.forEach(event => {
            document.addEventListener(event, () => {
                upgradePreload()
                cleanup()
            }, { passive: true, once: true })
        })
    }

    setupVideoEvents() {
        // Handle successful loading
        this.video.addEventListener("loadeddata", () => {
            this.video.play().catch(error => {
                console.warn('Video autoplay failed:', error)
            })
            this.video.classList.add("loaded")
        }, { once: true })

        // Handle loading errors
        this.video.addEventListener("error", (error) => {
            console.error('Video loading error:', error)
            this.video.classList.add("error")
        }, { once: true })
    }

    // Public method for WebGL coordination
    getVideoLoadPromise() {
        return new Promise((resolve) => {
            if (this.isLoaded && this.video.readyState >= 3) {
                resolve(this.video)
            } else {
                const onLoaded = () => {
                    resolve(this.video)
                    this.video.removeEventListener('loadeddata', onLoaded)
                }
                this.video.addEventListener('loadeddata', onLoaded)
                
                // Trigger loading if not started yet
                if (!this.isLoaded) {
                    this.loadVideo()
                }
            }
        })
    }

    // Cleanup method for page transitions
    destroy() {
        if (this.observer) {
            this.observer.disconnect()
            this.observer = null
        }
        
        // Clear WebGL coordination reference
        if (this.video) {
            this.video._loadVideoInstance = null
        }
        
        // Pause video to save resources
        if (this.video && !this.video.paused) {
            this.video.pause()
        }
    }
}
